=================== question1.asm =================
; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25834.0 

	TITLE	c:\K-State\cis450\runs\2018S\Assignment2\question1.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_s1
_DATA	SEGMENT
COMM	_ui:DWORD
_DATA	ENDS
_DATA	SEGMENT
_i	DD	018H
_s1	DW	0cH
_DATA	ENDS
PUBLIC	_main
_BSS	SEGMENT
_u2	DW	01H DUP (?)
_BSS	ENDS
_TEXT	SEGMENT
_y$ = -12						; size = 4
_x$ = -8						; size = 4
_c$ = -1						; size = 1
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_envp$ = 16						; size = 4
_main	PROC
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _s1
  0000d	6b 0d 00 00 00
	00 03		 imul	 ecx, DWORD PTR _i, 3 ; imul: signed integer multipy
									; ecx <= i * 3
  00014	03 c1		 add	 eax, ecx
  00016	89 45 f8	 mov	 DWORD PTR _x$[ebp], eax
  00019	8b 55 f8	 mov	 edx, DWORD PTR _x$[ebp]
  0001c	83 c2 06	 add	 edx, 6
  0001f	66 89 15 00 00
	00 00		 mov	 WORD PTR _u2, dx
  00026	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR _s1
  0002d	83 c0 0f	 add	 eax, 15			; 0000000fH
  00030	a3 00 00 00 00	 mov	 DWORD PTR _ui, eax
  00035	c6 45 ff 05	 mov	 BYTE PTR _c$[ebp], 5
  00039	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _y$[ebp], 0
$LN2@main:
  00040	83 7d f8 00	 cmp	 DWORD PTR _x$[ebp], 0
  00044	7e 20		 jle	 SHORT $LN3@main		; jle: jump if less than equal to
  00046	8b 4d f4	 mov	 ecx, DWORD PTR _y$[ebp]
  00049	83 c1 01	 add	 ecx, 1
  0004c	89 4d f4	 mov	 DWORD PTR _y$[ebp], ecx
  0004f	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR _u2
  00056	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  00059	2b c2		 sub	 eax, edx
  0005b	0f be 4d ff	 movsx	 ecx, BYTE PTR _c$[ebp]
  0005f	2b c1		 sub	 eax, ecx
  00061	89 45 f8	 mov	 DWORD PTR _x$[ebp], eax
  00064	eb da		 jmp	 SHORT $LN2@main
$LN3@main:
  00066	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _i
  0006c	d1 e2		 shl	 edx, 1		; shl  : shift left (1 bit)
  0006e	39 55 f8	 cmp	 DWORD PTR _x$[ebp], edx
  00071	7d 17		 jge	 SHORT $LN4@main	; jump if greater than equal to
  00073	0f be 45 ff	 movsx	 eax, BYTE PTR _c$[ebp]
  00077	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR _u2
  0007e	8d 54 88 2d	 lea	 edx, DWORD PTR [eax+ecx*4+45]  ; lea: load effective address
							; edx <= eax * ecx * 4 + 45
  00082	89 15 00 00 00
	00		 mov	 DWORD PTR _ui, edx
  00088	eb 13		 jmp	 SHORT $LN1@main
$LN4@main:
  0008a	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  0008d	03 45 f4	 add	 eax, DWORD PTR _y$[ebp]
  00090	0f be 4d ff	 movsx	 ecx, BYTE PTR _c$[ebp]
  00094	d1 e1		 shl	 ecx, 1
  00096	2b c1		 sub	 eax, ecx
  00098	a3 00 00 00 00	 mov	 DWORD PTR _i, eax
$LN1@main:
  0009d	33 c0		 xor	 eax, eax
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
END

============= question2.asm =====================
; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25834.0 

	TITLE	c:\K-State\cis450\runs\2018S\Assignment2\question2.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_y
_DATA	SEGMENT
COMM	_x:DWORD
_DATA	ENDS
_DATA	SEGMENT
_y	DD	014H
_DATA	ENDS
PUBLIC	_main
_TEXT	SEGMENT
_j$ = -8						; size = 4
_i$ = -4						; size = 4
_main	PROC
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 fc 14 00
	00 00		 mov	 DWORD PTR _i$[ebp], 20	; 00000014H
				; 20: constant (immediate addressing)
  0000d	eb 09		 jmp	 SHORT $LN4@main
$LN2@main:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@main:
  00018	83 7d fc 1e	 cmp	 DWORD PTR _i$[ebp], 30	; 0000001eH
					; 30: constant
  0001c	7f 34		 jg	 SHORT $LN1@main
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00021	0f af 0d 00 00
	00 00		 imul	 ecx, DWORD PTR _y ; ecx <- ecx * y
  00028	83 c1 21	 add	 ecx, 33			; 00000021H
  0002b	89 0d 00 00 00
	00		 mov	 DWORD PTR _x, ecx
  00031	83 3d 00 00 00
	00 14		 cmp	 DWORD PTR _x, 20	; 00000014H
  00038	7f 0b		 jg	 SHORT $LN5@main  ; jg: jump if greater than
  0003a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _x
  00040	89 55 f8	 mov	 DWORD PTR _j$[ebp], edx
  00043	eb 0b		 jmp	 SHORT $LN6@main
$LN5@main:
  00045	a1 00 00 00 00	 mov	 eax, DWORD PTR _x
  0004a	83 c0 02	 add	 eax, 2
  0004d	89 45 f8	 mov	 DWORD PTR _j$[ebp], eax
$LN6@main:
  00050	eb bd		 jmp	 SHORT $LN2@main
$LN1@main:
  00052	33 c0		 xor	 eax, eax
  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
END

===================== question3.s ====================
; Listing generated by Microsoft (R) Optimizing Compiler Version 19.12.25834.0 

	TITLE	c:\K-State\cis450\runs\2018S\Assignment2\question3.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_m
_DATA	SEGMENT
COMM	_i:DWORD
COMM	_c1:BYTE
_DATA	ENDS
_DATA	SEGMENT
_j	DD	03H
_m	DD	01H
?p@?1??trace_me@@9@9 DD 07H				; static int p declared in trace_me
$SG7350	DB	0aH, '%d', 09H, '%d', 09H, '%d', 09H, '%d', 09H, '%d', 09H
	DB	'%d', 0aH, 00H
	; this is string ""\n%d\t%d\t%d\t%d\t%d\t%d\n"
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_printf
PUBLIC	_trace_me
PUBLIC	_main
EXTRN	___acrt_iob_func:PROC
EXTRN	___stdio_common_vfprintf:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
?o@?1??trace_me@@9@9 DD 01H DUP (?)			; static int o declared in trace_me
_BSS	ENDS
_TEXT	SEGMENT
_main	PROC
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	c6 05 00 00 00
	00 02		 mov	 BYTE PTR _c1, 2
  0000a	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _c1
  00011	50		 push	 eax
  00012	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _m
  00018	51		 push	 ecx
  00019	6a 02		 push	 2
  0001b	e8 00 00 00 00	 call	 _trace_me
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	33 c0		 xor	 eax, eax
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
_TEXT	SEGMENT
_n$ = -4						; size = 4
_param1$ = 8						; size = 4
_param2$ = 12						; size = 4
_uc$ = 16						; size = 1
_trace_me PROC
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx	; esp -= 4 (ecx being pushed does not mean anything)
  00004	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR _n$[ebp], 3
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR _m
  00010	83 c0 01	 add	 eax, 1
  00013	a3 00 00 00 00	 mov	 DWORD PTR _m, eax
  00018	83 7d 08 00	 cmp	 DWORD PTR _param1$[ebp], 0
  0001c	75 30		 jne	 SHORT $LN2@trace_me ; jne: jump if not equal to
  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?p@?1??trace_me@@9@9
  00024	51		 push	 ecx
  00025	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?o@?1??trace_me@@9@9
  0002b	52		 push	 edx
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0002f	50		 push	 eax
  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _m
  00036	51		 push	 ecx
  00037	8b 55 0c	 mov	 edx, DWORD PTR _param2$[ebp]
  0003a	52		 push	 edx
  0003b	8b 45 08	 mov	 eax, DWORD PTR _param1$[ebp]
  0003e	50		 push	 eax
  0003f	68 00 00 00 00	 push	 OFFSET $SG7350
			; push the value of the string ""\n%d\t%d\t%d\t%d\t%d\t%d\n"
			; that is, push the address of the char array storing the string
  00044	e8 00 00 00 00	 call	 _printf
  00049	83 c4 1c	 add	 esp, 28			; 0000001cH
  0004c	eb 51		 jmp	 SHORT $LN1@trace_me
$LN2@trace_me:
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?o@?1??trace_me@@9@9
  00054	83 c1 01	 add	 ecx, 1
  00057	89 0d 00 00 00
	00		 mov	 DWORD PTR ?o@?1??trace_me@@9@9, ecx
  0005d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?p@?1??trace_me@@9@9
  00063	83 c2 01	 add	 edx, 1
  00066	89 15 00 00 00
	00		 mov	 DWORD PTR ?p@?1??trace_me@@9@9, edx
  0006c	8b 45 0c	 mov	 eax, DWORD PTR _param2$[ebp]
  0006f	83 c0 01	 add	 eax, 1
  00072	89 45 0c	 mov	 DWORD PTR _param2$[ebp], eax
  00075	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _c1
  0007b	80 c1 01	 add	 cl, 1
  0007e	88 0d 00 00 00
	00		 mov	 BYTE PTR _c1, cl
  00084	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _c1
  0008b	52		 push	 edx
  0008c	8b 45 0c	 mov	 eax, DWORD PTR _param2$[ebp]
  0008f	50		 push	 eax
  00090	8b 4d 08	 mov	 ecx, DWORD PTR _param1$[ebp]
  00093	83 e9 01	 sub	 ecx, 1
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 _trace_me
  0009c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@trace_me:
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
_trace_me ENDP
_TEXT	ENDS
END
