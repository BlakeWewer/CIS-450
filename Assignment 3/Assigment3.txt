		CS450	Assignment 3        Spring, 2018
Due: 12:20pm on 3/5 (Monday)

Note: I will be out of town on 3/3 and 3/4 (I will unable to reply to any mail)
      I will attend a seminor from 1:30 to 2:30 on 3/2 (Friday).
      So I will move my office hour to "between 2:30 and 4:00" on 3/2.
      Therefore, you must resolve all issues regarding the questions in this assignment by 4:00pm on 3/2.

1. Reverse compilation of gcc generated assembly code
"question1.s" is an assembly code file generated by gcc.
In the original c program, 
(1)void main() has two local variables; a 4-byte (int) variable m1 and a 2-byte variable m2.
   You must determine if m2 is signed or unsigned.

(2)void func( ) takes 3 int arguments, fp1, fp2, and fp3 (in this order)
   func() declares 3 local variables; two 2-byte variables (f1 and f2) and one 4-byte (int) variable f3.
   You must determine "signed" or "unsigned" of f1 and f2 (they may be the same or they may be different).
   The control structure of the compiler generated code of "func" is very complex (strange ?). 
   func() uses an if statement and a while statement.  The while statement is inside the if statement.
   The slide CS450-1_2-18 will help to understand the if and while structures.

   lines 27 and 28:
     movzwl    _s1, %eax
     movswl    %ax, %edx
   do the same thing as
     movswl    _s1, %edx (assuming %eax is not used)
   
   Similarly, lines 78 and 79:
     movzwl   _s2, %eax
     movzwl   %ax, %ebx
   do the same thing as
     movzwl   _s2, %ebx
   
   Lines 80 and 81:
     movzwl   _s1, %eax
     movswl   %ax, %ecx
   do the same as
     movswl   _s1, %ecx

   Line 88 pushes the 1st argument to printf, which is the address of string defined at line 15.
   In Line 15, '\11' is '\t', and '\12' is '\n'   '\0' is the terminator of the string 
   Recall that (1) "string" in C is represented by an array of char, terminating with '\0' and that (2) the value of a string is the starting address of the array holding the string.

   Question A:
   Reverse compile "question1.s".  Write your reverse-compiled c code in question1.c
   Also edit "question1.s" to insert source code lines in appropriate places as comments (assuming that a comment line starts with ";"), so that your source code lines are followed by corresponding assembly lines. Refer to (1) the third page in var_minix_cc.pdf in "FunctionCallTest1_Minix_X86" and (2) the second and third pages in var_gcc_x86.pdf in var in "FunctionCallTest1_gcc_x86."
   
   Question B:
   Draw a memory image of the execution of your question1.s (and question1.c) and simulate the execution.
   For each variable, you must write name, offset relative to esp (main) or to ebp (other functions) (if the variable is allocated in a stack frame), and history of values.
   When you need to update a value in a variable, cross off (do not erase) the old value and write the new value on the left side of the old value..
   When printf is called, you do not need to draw the local variable area of printf's frame.
   Assuming printf terminates normally, continue your simulation (and update values of variables) until the end of the execution.
   When a function returns, do not erase or cross off its frame.
   Write the output of this program.
   
2. Reverse compilation of VC_x86 code (one practice problem for Exam 1)
   "question2.asm" is an assembly program file generated by the VC_x86 program and edited by me.
   Question A:
   Reverse compile "question2.asm".  Write your reverse-compiled c code in question2.c
   Also edit "question2.asm" to insert source code lines in appropriate places as comments (assuming that a comment line starts with ";").
      
   Question B:
   Draw a memory image of the execution of your question2.asm (and question2.c) and simulate the execution.
   For each variable, you must write name, offset relative to ebp (if the variable is allocated in a stack frame), and history of values.
   When you need to update a value in a variable, cross off (do not erase) the old value and write the new value on the left side of the old value.
   When printf is called, you do not need to draw the local variable area of printf's frame.
   Assuming printf terminates normally, continue your simulation (and update values of variables) until the end of the execution.
   When a function returns, do not erase or cross off its frame.
   Write the output of this program.
   
3. Writing assembly code for VC_x86.
   Refer to "question3.c"
   You are to write the body of function g in x_86 assembly language.
   
   In the function prototype (line 6), g is defined as "int g();"
   However, g actually takes 4 arguments as shown in line 10 (and commented line 14).
   In the body, g does:
     1. allocate local variables "short s1" and "unsigned char uc1"
     2. assign c+5 to gc, s+10 to s1, uc+5 to uc1, and i to gi
     3. call f with gc, s1, uc1, gi in this order
     4. return the return value of invocation of f
          "return f(gc, s1, uc1, gi);"
  
   The output of the program is:
   i1 = -125	i2 = 33	i3 = 131	i5 = 3
   gc = -125	gi = 3	mi = -83

  
   Question A
   Complete your assembly code for the body of g in __asm{ }.
   Compile your program and execute it.
   To compile, 
      (1) open "x_86 Native Tools Command Prompt" in Visual Studio 2017
      (2) go to your work directory which has question3.c
      (3) issue:  "cl question3.c".  This will create question3.exe (assuming there is no error).
      (4) issue  "question3.exe" to execute the program. Confirm that your program produces the above output.
      
      Also, I strongly encourage you to generate .cod file by "cl /FAcs /Od /c question3.c" and check the generated assembly code.
      
      Actually, if I encounter a situation like this, in which I am forced to write an assembly code, I write a C code which does what I want to do in assembly code, run the compiler to generate the assembly code, and observe the assembly code.
      I consider this a very important technique to write system (low-level) programs.  So you may try it.
      However, because the question in Exam 2 on 3/14 will be very similar to this question, make sure (after you have completed the program) that you understand what you have written and that you will be able to write similar assembly code without looking at compiler generated code.
   
   Question B
   Draw a memory image of the execution of your program
   In particular, allocation of s1 and uc1 in g() is up to you. 
   So clearly specify where you allocate these variables.
   Write offsets of all local variables and parameters of the functions.
   
How to submit your work:
 1. make a top-level submission directory after your LastName_FirstName (e.g., Mizuno_Masaaki in my case)
 2. create three subdirectories, Question1, Question2, and Question3, in the top level directory.
 3. put your work (.c and/or .s/.asm file(s) and a figure in pdf, ppt(x), or jpg file; you can also put .txt or .doc file for additional explanation/comment) in the corresponding sub-directories.
 4. make a zip file of your top-level submission directory
 5. submit your zip file in KSOL.

